## 第六天学习
  ### 类型推论
    #### 基础
      类型推论会帮助提供类型 例如:let x=3;
      x会被推断为数字
    #### 最佳通用类型
      当需要从几个表达式中推断类型时，会选择一个最佳通用类型，但有时候没有能作为候选类型的类型 例如：
      let zoo=[new Rhino(),new Elephant(),new Snake()];
      这里会想让它被推断为animal[]，但是机器一般是不会推断出这个结果的，这时候就需要明确指出了，如果没找到的话，就会被推断
      为联合数组类(Rhino|Elephant|Snake)[]
    #### 上下文类型
      ts有时候会反向推论：
      就像
        window.onmousedown = function(mouseEvent){
            console.log(mouseEvent.button)
        }
        这个例子会得到一个类型错误，但是将mouseEvent定义为any，这里就不会报错了
       上下文类型会作为最佳推断类型来完成
    ### 类型兼容性
    #### 兼容性介绍
        ts结构化类型系统的基本规则就是，如果x想要兼容y，那么y中至少需要有x中相同的属性例如
          interface Named{
                name:string;
          }

          let x:Named;
          let y={name:"Alice",location:"Seattle"}
          x=y;
          这里检查t是否可以赋值给x时，需要检查x中每个属性，看能否在y中找到对应属性，这里，y必须包含名字是name的string类型
    #### 两个函数比较赋值
        有一个官方文档中的例子：
            let x=(a:number) => 0;
            let y=(b:number,s:string)=>0;

            y=x; //可以
            x=y; //error

            这里可以看后面的元素中参数属性在前面有没有，可以不考虑名字，如果都存在，就可以赋值
    #### 枚举
        枚举类型与数字类型兼容，但是不同枚举类型之间是不兼容的
    #### 类
        类与对象字面量的接口差不多，但是类有静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。
        静态函数和构造函数不在比较的范围内。


     到这里，ts的基础知识也差不多过完了，这里知识个人对官方文档的一些记录，如有记录不清楚的还是建议看官方文档，明天会继续看ts相关的高级类型等知识。

